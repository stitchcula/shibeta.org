extends frag/framework
block style
    style
        :stylus
            .yahei
                font-family "Microsoft YaHei"
            a.btn
                margin-top 20px
            .hide
                display none
block content
    main
        div.container
            div.row
                div.col.s12
                    ul.tabs.z-depth-1
                        li.tab.col.s6
                            a(href="#steady").yahei 稳态
                        li.tab.col.s6
                            a(href="#unsteady").yahei 非稳态
                        li.tab.col.s6
                            a.active(href="#about").yahei 关于
                div#steady.col.s12.canvas-input
                    h4.yahei 稳态下温度随缝深分布规律
                    br
                    div.row
                        div.col.l6.m12.s12
                            p.yahei.red-text 输入参数：
                            div.row
                                div.input-field.col.s12
                                    input.validate.yahei(type="text",placeholder="单位:°C.")
                                    label.yahei 火源温度Tf
                                div.input-field.col.s12
                                    input.validate.yahei(type="text",placeholder="大于1且不大于4,单位:cm.")
                                    label.yahei 混凝土板缝宽
                                div.col.s12.m6.l6
                                    a.btn.waves-effect.yahei.right#steady_run 计算
                                div.col.s12.m6.l6
                                    a.btn.waves-effect.waves-light.yahei.red.right#steady_clean 清空
                        div.col.l6.m12.s12.canvas-container#steady_result
                            p.yahei.red-text 温度(Tg)随缝深(y)变化的曲线：
                            canvas#steady_result_canvas
                            img.responsive-img.materialboxed#steady_result_img.hide
                div#unsteady.col.s12.canvas-input
                    h4.yahei 非稳态下温度随缝深分布规律
                    br
                    div.row
                        div.col.l6.m12.s12
                            p.yahei.red-text 输入参数：
                            div.row
                                div.input-field.col.s12
                                    input.validate.yahei(type="text",placeholder="单位:°C.")
                                    label.yahei 火源温度Tf
                                div.input-field.col.s12
                                    input.validate.yahei(type="text",placeholder="大于1且不大于4,单位:cm.")
                                    label.yahei 混凝土板缝宽
                                div.col.s12.m6.l6
                                    a.btn.waves-effect.yahei.right#unsteady_run 计算
                                div.col.s12.m6.l6
                                    a.btn.waves-effect.waves-light.yahei.red.right#unsteady_clean 清空
                        div.col.l6.m12.s12.canvas-container#unsteady_result
                            p.yahei.red-text 温度(Tg)随缝深(y)与时间(t)变化的曲线：
                            canvas#unsteady_result_canvas.hide
                            img.responsive-img.materialboxed#unsteady_result_img
                div#about.col.s12
                    h4.yahei 关于该计算平台
                    p.yahei _(:зゝ∠)_我也不知道说什么好


    script.
        $(function(){
            $('ul.tabs').tabs()
            $('#steady_result').fadeOut(0)
            $('#unsteady_result').fadeOut(0)
            $('.materialboxed').materialbox()

            $('#steady_run').click(function(){
                $('#steady_result').fadeIn(300,function(){
                    CanvasReset(cSteady)
                    //$(window).resize(function(){CanvasReset(cSteady)})
                })
            })

            $('#steady_clean').click(function(){
                $('#steady_result').fadeOut(300)
                var p = document.querySelectorAll("#steady input")
                for (i = 0; i <= p.length; i++) if (p[i]) p[i].value = null
            })

            $('#unsteady_run').click(function(){
                $('#unsteady_result').fadeIn(300,function(){
                    CanvasReset(cUnsteady)
                    //$(window).resize(function(){CanvasReset(cUnsteady)})
                })
            })

            $('#unsteady_clean').click(function(){
                $('#unsteady_result').fadeOut(300)
                var p = document.querySelectorAll("#unsteady input")
                for (i = 0; i <= p.length; i++) if (p[i]) p[i].value = null
            })

            //canvas init
            var cSteady={id:"#steady_result_canvas",img:"#steady_result_img",x:0,y:0,points:[],max:{},offsetX:60,offsetY:20}//画布域
                ,cUnsteady={id:"#unsteady_result_canvas",img:"#unsteady_result_img",x:0,y:0,points:[],max:{},offsetX:240,offsetY:40,MaxT:2000}
            var offsetX=60,offsetY=20

            //fSteady(360,3.6)
            /*******************functions*********************/
            //canvas
            function CanvasReset(canvases,fCanvasPaint,scale){//canvas=[{id:"",x:0,y:0}]
                if(!canvases.length) canvases=[canvases]
                scale=scale||0.6
                for(var i=0;i<canvases.length;i++){
                    var canvas=$(canvases[i].id)

                    var container=$(canvases[i].id).closest('.canvas-container')
                    if(canvases[i].id=="#unsteady_result_canvas") canvases[i].x=1280//
                    else canvases[i].x = parseInt(container.width())
                    canvases[i].y=parseInt(canvases[i].x*scale)
                    canvas.attr("width",canvases[i].x+"px")
                    canvas.attr("height",canvases[i].y+"px")

                    //fCanvasPaint(canvases[i].id)
                    var dataUrl=CanvasPaint(canvases[i])
                    if(canvases[i].id=="#unsteady_result_canvas") $(canvases[i].img).get(0).src=dataUrl
                }
            }

            function CanvasPaint(p){
                CanvasCal(p)

                var ctx=$(p.id).get(0).getContext('2d')
                ctx.clearRect(0, 0, p.x, p.y)

                if(p.id=="#steady_result_canvas") {
                    ctx.beginPath()
                    ctx.lineWidth = 1
                    ctx.strokeStyle = '#ee6e73'
                    ctx.lineJoin = 'round'
                    ctx.moveTo(p.points[0].x,p.points[0].y)
                    for (var i = 1; i < p.points.length; i++)
                        ctx.lineTo(p.points[i].x, p.points[i].y)
                    ctx.stroke()
                }
                if(p.id=="#unsteady_result_canvas") {
                    ctx.lineWidth = 1
                    for(var j=0;j<p.points.length; j++){//p.points.length
                        ctx.strokeStyle=p.points[j].z
                        ctx.beginPath()
                        ctx.moveTo(p.points[j].x-0.5, p.points[j].y+0.5)
                        ctx.lineTo(p.points[j].x+0.5, p.points[j].y-0.5)
                        ctx.stroke()
                    }
                }
                CanvasPaintCoo(p)

                return $(p.id).get(0).toDataURL("image/png")
            }

            function CanvasPaintCoo(p,arr,color){
                if(!color||!color.length) color=[]

                var ctx=$(p.id).get(0).getContext('2d')
                ctx.lineWidth=1

                if(p.id=="#steady_result_canvas") {
                    ctx.beginPath()
                    ctx.strokeStyle = color[0] || '#4CAF50'
                    ctx.moveTo(p.offsetX + 0.5, p.max.y)
                    ctx.lineTo(p.max.x, p.max.y)
                    ctx.lineTo(p.max.x, p.y - 0.5 - offsetY)
                    ctx.moveTo(p.offsetX + 0.5, p.points[p.points.length - 1].y)
                    ctx.lineTo(p.points[p.points.length - 16].x, p.points[p.points.length - 8].y)
                    ctx.lineTo(p.points[p.points.length - 16].x, p.y - 0.5 - offsetY)
                    ctx.stroke()

                    ctx.font = "15px Courier New"
                    ctx.fillStyle = color[1] || "#9e9e9e"
                    ctx.fillText(0, 40.5, p.y - 1.5)
                    ctx.fillText(parseFloat(p.max.Tg).toFixed(1), 0.5, parseInt(p.max.y + 15 / 2) - 0.5)
                    ctx.fillText(parseFloat(p.points[0].Tg).toFixed(1), 0.5, parseInt(p.points[0].y + 15 / 2) - 0.5)
                    ctx.fillText(parseFloat(p.points[p.points.length - 16].Tg).toFixed(1), 0.5, parseInt(p.points[p.points.length - 16].y + 15 / 2) - 0.5)
                    ctx.fillText(parseFloat(p.max.Wy).toFixed(1), parseInt(p.max.x - 15 / 2) - 15.5, p.y - 1.5)
                    ctx.fillText(parseFloat(p.points[p.points.length - 16].Wy).toFixed(1), parseInt(p.points[p.points.length - 16].x - 15 / 2) - 15.5, p.y - 1.5)
                }
                if(p.id=="#unsteady_result_canvas") {
                    ctx.lineWidth=2

                    ctx.beginPath()
                    ctx.strokeStyle = color[0] || '#4CAF50'
                    ctx.font = "32px Courier New"
                    ctx.fillStyle = color[1] || "#9e9e9e"

                    var detaY=(p.y-p.offsetY)/8
                    for(var i=0;i<8;i++){
                        ctx.moveTo(p.offsetX+0.5,i*detaY+0.5)
                        ctx.lineTo(p.x+0.5,i*detaY+0.5)
                        ctx.fillText((0.8-0.1*i).toFixed(1),p.offsetX-72,i*detaY+20.5)
                    }
                    ctx.stroke()
                }
                //
                ctx.beginPath()
                ctx.strokeStyle=color[2]||'#2bbbad'
                ctx.moveTo(p.offsetX+0.5,0.5)
                ctx.lineTo(p.offsetX+0.5,p.y-0.5-p.offsetY)
                ctx.lineTo(p.offsetX+p.x-0.5,p.y-0.5-p.offsetY)
                ctx.stroke()
            }

            function CanvasCal(p){//获取input并计算
                var canvasInput=$(p.id).closest(".canvas-input")[0]
                var Tf=parseFloat($("input",canvasInput)[0].value)
                var w=parseFloat($("input",canvasInput)[1].value)
                if(!Tf||!w||w<=1||w>4) return -1
                if(p.id=="#steady_result_canvas"){
                    return fSteady(Tf,w,p)
                }
                if(p.id=="#unsteady_result_canvas"){
                    return fUnsteady(Tf,w,p)
                }
            }

            //calculate
            function fSteady(Tf,w,p){
                if (w > 4 || w < 1) return -1
                var Lg = fLg(w)
                var Tc = fTc(w)
                if(typeof(p)!="object") return fTg(Lg,Tc,Tf,w,p)//返回确定y时Tg的值

                var max=fGetMax(0.001,Lg,Tc,Tf,w)
                var detaX=max.x/p.x

                p.points=[]
                for(var i=0.5;i<=p.x-p.offsetX;i=i+1){//采样精度
                    var Tg=fTg(Lg,Tc,Tf,w,(i-0.5)*detaX)
                    p.points.push({x:p.offsetX+i,Tg:Tg,Wy:(i-0.5)*detaX})
                }
                //find the max point,奇怪的js垃圾算法
                p.max = {x: 0, y: 0, Tg: 0}
                for(var j=0;j<p.points.length;j++){
                    p.max.Tg=Math.max(p.points[j].Tg,p.max.Tg)
                }

                var scaleY=(p.y-p.offsetY)/p.max.Tg
                for(var k=0;k<p.points.length;k++){
                    if(p.points[k].Tg==p.max.Tg) p.max=p.points[k]
                    p.points[k].y=p.y-p.points[k].Tg*scaleY
                }
                return p.points
            }

            function fUnsteady(Tf,w,p,t){//p->y,t可选
                if (w > 4 || w < 1) return -1
                var Lg = fLg(w)
                var Tc = fTc(w)
                if(typeof(p)!="object") return fUnTg(Lg,Tc,Tf,w,p,t)

                //p.MaxT=2000//时间范围
                detaX=p.MaxT/(p.x-p.offsetX)
                detaY=0.8/(p.y-p.offsetY)

                //优化的快速算法

                p.points=new Array((p.x-p.offsetX)*(p.y-p.offsetY))
                for(var ix=0.5;ix<=p.x-p.offsetX;ix=ix+1)
                    for(var iy=0.5;iy<=p.y-p.offsetY;iy=iy+1){
                        var Tg=fUnTg(Lg,Tc,Tf,w,(iy-0.5)*detaY,(ix-0.5)*detaX)
                        p.points[(ix-0.5)*(p.y-p.offsetY)+iy-0.5]={x:p.offsetX+ix,y:p.y-p.offsetY-iy,Tg:Tg,t:((ix-0.5)*detaX).toFixed(1),Wy:((iy-0.5)*detaY).toFixed(1)}
                    }
                /*
                p.points=[]
                for(var ix=0.5;ix<=p.x-p.offsetX;ix=ix+1)
                    for(var iy=0.5;iy<=p.y-p.offsetY;iy=iy+1){
                        var Tg=fUnTg(Lg,Tc,Tf,w,(iy-0.5)*detaY,(ix-0.5)*detaX)
                        p.points.push({x:p.offsetX+ix,y:p.y-p.offsetY-iy,Tg:Tg,t:((ix-0.5)*detaX).toFixed(1),Wy:((iy-0.5)*detaY).toFixed(1)})
                    }
                    */
                //find the max point,奇怪的js垃圾算法
                p.max = {x: 0, y: 0,z:0 ,Tg: 0}
                for(var j=0;j<p.points.length;j++){
                    p.max.Tg=Math.max(p.points[j].Tg,p.max.Tg)
                }

                var scaleZ=510/p.max.Tg
                for(var k=0;k<p.points.length;k++){
                    if(p.points[k].Tg==p.max.Tg) p.max=p.points[k]
                    var r=Math.round(p.points[k].Tg*scaleZ)
                        ,g=255
                    if(r>255){
                        g=510-r
                        r=255
                    }
                    p.points[k].z='rgba('+r+','+g+',0,1)'
                }
                return p.points
            }

            function fGetMax(x,Lg,Tc,Tf,w){
                var Tgmax=0
                for(var Ymax=2;;Ymax++){
                    var res=fTg(Lg,Tc,Tf,w,Ymax)
                    Tgmax=Math.max(Tgmax,res)
                    var last=fTg(Lg,Tc,Tf,w,Ymax-1)
                    if(last>res&&Math.abs(last-res)/last<x) return {x:Ymax,y:Tgmax}//Ymax
                }
            }

            function fTg(Lg,Tc,Tf,w,y){
                var Tm=((Tf+273)-(Tc+0)-2576.8*w)*Math.exp(-1*y*Math.sqrt(15/(Lg*w)))
                        +2576.8*w*Math.exp(-0.4281*y)
                        +Tc
                return (Tm.toFixed(4))
            }

            function fUnTg(Lg,Tc,Tf,w,y,t){
                var Tm=fTg(Lg,Tc,Tf,w,y)
                var K2=fK2(w,y)
                var Tg=Tm/(1+(Tm-298)/298*Math.exp(-1*Tm*t*K2*0.000001))
                return (Tg.toFixed(4))
            }

            function fLg(w){
                if(w>4) return -1
                if(w>3) return (6.0-(6.0-3.75)/1.0*(w-3))
                if(w>2) return (8.0-(8.0-6.0)/1.0*(w-2))
                if(w>1.5) return (10.5-(10.5-8.0)/0.5*(w-1.5))
                if(w>=1) return (15.5-(15.5-10.5)/0.5*(w-1.0))
                else return -1
            }

            function fTc(w){
                if(w>4) return -1
                if(w>3) return (390+(480-390)/1.0*(w-3))
                if(w>2) return (380+(390-380)/1.0*(w-2))
                if(w>1.5) return (320+(380-320)/0.5*(w-1.5))
                if(w>=1) return (320+(320-320)/0.5*(w-1.0))
                else return -1
            }

            function fK2(w,y){//*0.000001
                var k=[
                    [10.3,2.5,0.6,0.4,0.6,0.8,1.0,1.4,1.35,1.3,1.25,1.2,1.15,1.1,1.05,1.0,1.1,1.1,1.2,0.9,0.5],
                    [11.0,4.0,1.2,0.8,1.0,1.6,2.2,3.2,5.4,7.8,7.8,7.8,7.8,7.0,6.0,4.6,3.4,2.6,3.0,3.0,2.0],
                    [11.0,6.5,1.8,1.0,1.6,4.8,12.0,12.1,12.1,12.0,11.8,11.6,11.7,11.7,11.7,11.7,11.7,12.2,13.6,14.1,15.8],
                    [11.0,8.9,6.6,4.0,6.2,7.2,9.0,10.5,12.0,13.6,13.8,14.0,14.2,14.4,14.6,14.8,15.0,15.2,14.5,14.7,16.5],
                    [11.2,10.0,9.3,9.3,9.4,9.6,11.5,12.5,12.0,11.8,11.5,11.0,11.13,11.26,11.39,11.52,11.65,11.8,11.5,11.3,14.8]
                ]
                    ,detaKn=[0.5,0.5,1,1]
                    ,LKn=[1,1.5,2,3]
                    ,kn=0
                if(w>4) return -1
                if(w>3) kn=3
                if(w>2) kn=2
                if(w>1.5) kn=1
                if(w>=1) kn=0
                else return -1
                var km=parseInt(y/0.04)
                var K21=k[kn][km]+(k[kn][km+1]-k[kn][km])/0.04*(y-km*0.04)
                var K22=k[kn+1][km]+(k[kn+1][km+1]-k[kn+1][km])/0.04*(y-km*0.04)
                var K2=K21+(K22-K21)/detaKn[kn]*(w-LKn[kn])
                return K2
            }
        })